* Prerequisites

*** We have an intuition on why FP matters
    - You have already heard why functional-programming matters: writting
      software that is:
      + modular
      + maintainable 
      + understandable
      + testable
      + enjoyable to write
    - You want to find out whether this is indeed true.

*** Our goals
    We share these goals[fn:1]:
    - Abstractions:
      - precise
      - elegant
      - reusable
    - Implementations:
      - correct
      - efficient
      - maintainable
    - Documentation:
      - clear
      - simple
      - accurate

* What is functional-programming
  - An abused term:
    - Lambdas?
    - Map, filter, reduce?
    - Category theory?
    - Programming with functions? 
      # well in this case most Java programs are FP!
  - What I understand is inline with *denotative* programming:
    - Nested expression structure
    - Each expression *denotes* something
    - Depending only on denotations of sub-expressions.

      
*** Example:
    
    TODO: Show a non-declarative program and its declarative counterpart.
    #+BEGIN_SRC java
    private Int x;
    y = obj.doSth() // Mutates `x`
    z = obj.doSthElse(y)
    // ...
    return compute(z + x) // Not depending only on subexpressions.
    #+END_SRC

* About this presentation
  Goals: Show:
  - Haskell features *I* like, 
  - Why *I think* it is a suitable mean for learning FP.

* Haskell sucks
  - Less libraries
  - Smaller community
  - String, Text, ByteString, argh!
  - Namespace could be improved.
  - Lot's of compiler extensions: comparable to C++ sub-languages (C++
    is a federation of languages and each team uses a particular
    sub-set of them).
  - Lazy: difficult to reason about space-complexity (althoug there are
    good profiling tools)

* Haskell misconceptions

  - Haskell is hard:
    - The language has barely 22 constructs.
    - It is functional-programming what is hard.
      - Unlike OO:
        - dependency injection frameworks,
        - gang-of-four patterns,
        - concurrency

*** COMMENT Keywords
    Keywords[fn:2]:
    0. [@0] ~->~
    1. ~=>~
    2. ~--~
    3. ~=~
    4. ~@~
    5. ~_~
    6. ~\~
    7. ~|~
    8. ~as~
    #+REVEAL: split
    9. [@9] ~case ... of~
    10. ~class~
    11. ~data~
    12. ~deriving~
    13. ~do~
    14. ~hiding~
    15. ~import~
    16. ~if ... then ... else~
    #+REVEAL: split
    17. [@17]~let ... in~
    18. ~module~
    19. ~newtype~
    20. ~qualified~
    21. ~type~
    22. ~where~
       

* ~n~ things I like about Haskell
  
*** Less noise (more power to weight)

***** Function declaration
      #+BEGIN_SRC haskell
      hello = "Hello world"
      #+END_SRC

      No ~function~, ~def~, brackets, etc.

***** Function application is juxtaposition
      In a functional language function application is one of the most used
      operators.
      #+BEGIN_SRC haskell
        f x y = 2 * x + y
        g z = f z z -- (f z) z
      #+END_SRC

      In Scala:
      #+BEGIN_SRC scala
        def f(x: ???, y: ???): ??? = 2 * x + y
        def f(z: ???): ??? = f (z, z)
      #+END_SRC

***** Curried by default
      No need to decide between:
      #+BEGIN_SRC scala
        def willINeedCurry(x, y, z) = ???
      #+END_SRC
      or
      #+BEGIN_SRC scala
        def willINeedCurry(x)(y)(z) = ???
      #+END_SRC

      #+BEGIN_SRC haskell
        thisIsCurried x y z = undefined
      #+END_SRC

      One less thing to worry about!

***** Infix-operators
      Ready to use!
      #+BEGIN_SRC haskell
        like a b = a ++ " like " ++ b
        like "dogs" "meat"
        "pandas" `like` "bamboo"
      #+END_SRC

***** Separation function types and definitions
      #+BEGIN_SRC haskell
        sayHello :: String -> String
        sayHello name = "Hello " ++ name
      #+END_SRC

      Partial application, and point free syntax:
      #+BEGIN_SRC haskell
        sayHello = ("Hello " ++)
      #+END_SRC

***** Function composition is the dot
      Because ~andThen~ is way too long...
      #+BEGIN_SRC haskell
        screamHello = sayHello . capitalize
      #+END_SRC

*** Lists
    Lists are the workhorse of functional-programming.
    #+BEGIN_SRC haskell
      countries = ["The Netherlands", "Poland", "Turkey", "India", "Argentina"]
      evenNumbers = [0, 2, 4]
    #+END_SRC
    
***** Lists comprehensions 
      #+BEGIN_SRC haskell
        oddNumbers = [ i * 2 + 1 | i <- [0..]]
        pairs = [(i,j) | i <- [1,2], j <- [1..4]
      #+END_SRC

      Can't get any more mathematical than this...

*** Lambda expressions 
    #+BEGIN_SRC haskell
      duplicate = map (\x -> x ++ x)
      res0 = duplicate ["foo", "bar"]
    #+END_SRC

*** Algebraic data types
    #+BEGIN_SRC haskell
      data MList a = Nil | Cons a (MList a)
    #+END_SRC

    Compare with:
    #+BEGIN_SRC scala
      sealed trait List[+A]
      case object Nil extends List[Nothing]
      case class Cons[+A](head: A, tail: List[A]) extends List[A]
    #+END_SRC

    No need to worry about:
    - Variance
    - Classes, objects, inheritance
    - Lots of symbols!

*** TODO It has a REPL
    :t, :i, :l, :r

*** Typeclasses
    Full blown FP makes extensive use of *typeclasses*.

    
***** A Scala Monoid and an instance
      #+BEGIN_SRC scala
        trait Monoid[A] {
          def empty: A
          def combine(x: A, y: A): A
        }

        // Implementation for Int
        val intAdditionMonoid: Monoid[Int] = new Monoid[Int] {
          def empty: Int = 0
          def combine(x: Int, y: Int): Int = x + y
        }    
      #+END_SRC

***** A Haskell Monoid and an instance
      #+BEGIN_SRC haskell
        class Monoid a where
          mempty  :: a
          mappend :: a -> a -> a

        instance Monoid Int where
          mempty = 0
          mappend = +
      #+END_SRC
      - Give things the right name: it is not a plane, it is not a bird, it is
        not a ~val~, it is an ~instance~!

***** Derived instances
      When things start to get hairy...

******* Deriving instances in Scala
        #+BEGIN_SRC scala
          final case class Pair[A, B](first: A, second: B)

          def deriveMonoidPair[A, B](A: Monoid[A], B: Monoid[B]): Monoid[Pair[A, B]] =
            new Monoid[Pair[A, B]] {
              def empty: Pair[A, B] = Pair(A.empty, B.empty)

              def combine(x: Pair[A, B], y: Pair[A, B]): Pair[A, B] =
                Pair(A.combine(x.first, y.first), B.combine(x.second, y.second))
            }
        #+END_SRC

******* Deriving instances in Haskell
        #+BEGIN_SRC haskell
          instance (Monoid a, Monoid b) => Monoid (a, b) where
            mempty = (mempty, mempty) -- No A.empty, B.empty, let the compiler work for
                                      -- us and we use our time to do cool stuff.
            mappend (a1, b1) `mappend` (a2, b2) =
              (a1 `mappend` a2, b1 `mappend` b2)
        #+END_SRC
        We can almost read this!

*** Declarative

***** Quicksort Scala
      #+BEGIN_SRC scala
        def qsort[T <% Ordered[T]](list: List[T]): List[T] = {
          list match {
          case Nil => Nil     
          case x::xs =>        
            val (before, after) = xs partition (_ < x)
            qsort(before) ++ (x :: qsort(after))
          }
        }      
      #+END_SRC

***** Quicksort 
      #+BEGIN_SRC haskell
        qsort :: Ord a => [a] -> [a]
        qsort [] = []
        qsort (x:xs) = qsort [b | b <- xs, b <= x] ++ [x] ++ qsort [a | a <- xs, x < a]
      #+END_SRC
      
*** TODO Do syntax
    - No ~yield~ required the end.
    - No dummy ~<-~.

*** Side-effects cannot just be introduced anywhere

*** Composing effects via monad transformers
    Show your example from SO.
*** Concurrent programming

***** Lightweight threads

***** STM

*** Great extensions 

***** GADT's

***** Rank-N-Types

***** Automatic derivation!
* Why Haskell for FP (and not Scala)

*** No variance, contra-variance
    
*** No partial application on types 

***** State monad Scala
      #+BEGIN_SRC scala
        def stateMonad[S] = new Monad[({type f[x] = State[S,x]})#f] {
          def unit[A](a: => A): State[S,A] = ???
          def flatMap[A, B](st: State[S, A])(f: A => State[S,B]): State[S, B] = ???
        }
      #+END_SRC

      Yes, I know there is a kind-projector plugin, but still it is more awkward than:

***** State monad Haskell
      #+BEGIN_SRC haskell
        instance Monad (State s) where
          return x = undefined
          sa >>= fsb = undefined
      #+END_SRC

*** TODO Add also material from these references
    https://www.reddit.com/r/haskell/comments/3h7fqr/what_are_haskellers_critiques_of_scala/
* Is Haskell production ready?
  - Build tools (stack).
  - It actually has a mature FP library
  - ...

* More
  - http://bob.ippoli.to/why-haskell-2013/
* Footnotes

[fn:2] https://wiki.haskell.org/Keywords

[fn:1] https://github.com/conal/talk-2014-lambdajam-denotational-design
